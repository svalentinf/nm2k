<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NMEA 2000 PGN Monitor</title>
    <script src="js/vue.global.js"></script>
    <style>
        :root {
            --primary: #3b82f6;
            --primary-dark: #2563eb;
            --secondary: #10b981;
            --danger: #ef4444;
            --warning: #f59e0b;
            --dark-bg: #0f172a;
            --card-bg: #1e293b;
            --border: #334155;
            --text: #f8fafc;
            --text-light: #94a3b8;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--dark-bg);
            color: var(--text);
            min-height: 100vh;
            padding: 20px;
        }

        .app-container {
            max-width: 2000px;
            margin: 0 auto;
        }

        /* Header */
        header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid var(--border);
        }

        h1 {
            font-size: 2.5rem;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }

        .status {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 8px 20px;
            border-radius: 20px;
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid var(--primary);
            font-weight: 600;
        }

        .status.connected {
            background: rgba(16, 185, 129, 0.1);
            border-color: var(--secondary);
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--danger);
            animation: pulse 2s infinite;
        }

        .status.connected .status-dot {
            background: var(--secondary);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.5;
            }
        }

        /* Stats */
        .stats-bar {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
        }

        .stat-number {
            font-size: 2.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            line-height: 1;
        }

        .stat-label {
            color: var(--text-light);
            font-size: 0.9rem;
            margin-top: 5px;
        }

        /* Controls */
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 10px 20px;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn:hover {
            background: var(--primary-dark);
            transform: translateY(-1px);
        }

        .btn-outline {
            background: transparent;
            border: 1px solid var(--border);
        }

        .btn-outline:hover {
            background: var(--card-bg);
        }

        .search {
            flex: 1;
            min-width: 200px;
            padding: 10px 15px;
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text);
            font-size: 1rem;
        }

        .search:focus {
            outline: none;
            border-color: var(--primary);
        }

        select.search {
            max-width: 200px;
        }

        /* Dashboard Layout */
        .dashboard {
            display: grid;
            grid-template-columns: 300px 1fr 350px;
            gap: 20px;
            height: calc(100vh - 250px);
        }

        @media (max-width: 1400px) {
            .dashboard {
                grid-template-columns: 250px 1fr;
                grid-template-rows: auto auto;
            }
        }

        @media (max-width: 1024px) {
            .dashboard {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto auto;
                height: auto;
            }
        }

        /* Panels */
        .panel {
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 12px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .panel-header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .panel-title {
            font-size: 1.2rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        /* Devices Panel */
        .devices-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .device-card {
            background: rgba(30, 41, 59, 0.5);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .device-card:hover {
            border-color: var(--primary);
            transform: translateY(-2px);
        }

        .device-card.active {
            border-color: var(--primary);
            background: rgba(59, 130, 246, 0.1);
        }

        .device-name {
            font-weight: 600;
            font-size: 1.1rem;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .device-src {
            background: var(--primary);
            color: white;
            padding: 2px 10px;
            border-radius: 12px;
            font-size: 0.9rem;
        }

        .device-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        .device-stat {
            font-size: 0.85rem;
        }

        .device-stat-label {
            color: var(--text-light);
            margin-bottom: 2px;
        }

        .device-stat-value {
            font-weight: 600;
        }

        /* PGNs Panel */
        .pgns-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 15px;
        }

        .pgn-card {
            background: rgba(30, 41, 59, 0.5);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 15px;
            transition: all 0.3s;
        }

        .pgn-card.updated {
            animation: highlight 1s;
        }

        @keyframes highlight {
            0% {
                border-color: var(--secondary);
                background: rgba(16, 185, 129, 0.1);
            }
            100% {
                border-color: var(--border);
                background: rgba(30, 41, 59, 0.5);
            }
        }

        .pgn-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 10px;
        }

        .pgn-id {
            font-family: 'Courier New', monospace;
            background: rgba(59, 130, 246, 0.2);
            padding: 4px 10px;
            border-radius: 6px;
            font-weight: 600;
            font-size: 0.95rem;
        }

        .pgn-description {
            color: var(--text-light);
            margin-bottom: 15px;
            line-height: 1.4;
            font-size: 0.95rem;
        }

        .fields-grid {
            display: grid;
            gap: 8px;
        }

        .field-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            transition: all 0.2s;
        }

        .field-row.updated {
            animation: fieldUpdate 0.5s;
            background: rgba(16, 185, 129, 0.1);
        }

        @keyframes fieldUpdate {
            0% {
                background: rgba(16, 185, 129, 0.3);
            }
            100% {
                background: rgba(16, 185, 129, 0.1);
            }
        }

        .field-name {
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--text-light);
        }

        .field-value {
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            max-width: 60%;
            text-align: right;
            word-break: break-all;
        }

        .pgn-footer {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85rem;
            color: var(--text-light);
        }

        /* History Panel */
        .history-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .history-item {
            background: rgba(30, 41, 59, 0.5);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 15px;
        }

        .history-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .history-pgn {
            font-weight: 600;
            color: var(--primary);
        }

        .history-device {
            color: var(--text-light);
            font-size: 0.9rem;
        }

        .history-time {
            font-size: 0.8rem;
            color: var(--text-light);
            margin-top: 5px;
            text-align: right;
        }

        .history-description {
            font-size: 0.9rem;
            color: var(--text);
            margin-bottom: 5px;
        }

        /* Empty States */
        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-light);
        }

        .empty-state i {
            font-size: 3rem;
            margin-bottom: 15px;
            opacity: 0.5;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--card-bg);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary);
        }
    </style>
</head>
<body>
<div id="app">
    <div class="app-container">
        <header>
            <h1>NMEA 2000 PGN Monitor</h1>
            <div class="status" :class="{ connected: isConnected }">
                <div class="status-dot"></div>
                <span>{{ connectionStatus }}</span>
                <span v-if="isConnected">• {{ totalDevices }} devices • {{ totalPgns }} PGNs</span>
            </div>
        </header>

        <div class="stats-bar">
            <div class="stat-card">
                <div class="stat-number">{{ totalDevices }}</div>
                <div class="stat-label">Devices</div>
            </div>
            <div class="stat-card">
                <div class="stat-number">{{ totalPgns }}</div>
                <div class="stat-label">Active PGNs</div>
            </div>
            <div class="stat-card">
                <div class="stat-number">{{ totalUpdates }}</div>
                <div class="stat-label">Total Updates</div>
            </div>
            <div class="stat-card">
                <div class="stat-number">{{ history.length }}</div>
                <div class="stat-label">History Entries</div>
            </div>
        </div>

        <div class="controls">
            <button class="btn" @click="toggleAutoUpdate">
                <i :class="autoUpdate ? 'fas fa-pause' : 'fas fa-play'"></i>
                {{ autoUpdate ? 'Pause Updates' : 'Resume Updates' }}
            </button>
            <button class="btn btn-outline" @click="clearHistory">
                <i class="fas fa-trash"></i> Clear History
            </button>
            <input
                    v-model="searchQuery"
                    placeholder="Search PGNs or fields..."
                    class="search"
            >
            <select v-model="deviceFilter" class="search">
                <option value="">All Devices</option>
                <option v-for="device in devicesList" :value="device.src">
                    Device {{ device.src }} ({{ device.pgnCount }} PGNs)
                </option>
            </select>
            <select v-model="pgnFilter" class="search">
                <option value="">All PGNs</option>
                <option v-for="pgn in uniquePgns" :value="pgn">
                    PGN {{ pgn }}
                </option>
            </select>
        </div>

        <div class="dashboard">
            <!-- Devices Panel -->
            <div class="panel">
                <div class="panel-header">
                    <h3 class="panel-title">
                        <i class="fas fa-microchip"></i>
                        Connected Devices
                    </h3>
                    <span class="stat-number" style="font-size: 1.5rem;">{{ devicesList.length }}</span>
                </div>
                <div class="panel-content">
                    <div class="devices-list">
                        <div
                                v-for="device in devicesList"
                                :key="device.src"
                                class="device-card"
                                :class="{ active: selectedDevice === device.src }"
                                @click="selectDevice(device.src)"
                        >
                            <div class="device-name">
                                <span>Device {{ device.src }}</span>
                                <span class="device-src">SRC: {{ device.src }}</span>
                            </div>
                            <div class="device-stats">
                                <div class="device-stat">
                                    <div class="device-stat-label">PGNs</div>
                                    <div class="device-stat-value">{{ device.pgnCount }}</div>
                                </div>
                                <div class="device-stat">
                                    <div class="device-stat-label">Updates</div>
                                    <div class="device-stat-value">{{ device.updates }}</div>
                                </div>
                                <div class="device-stat">
                                    <div class="device-stat-label">First Seen</div>
                                    <div class="device-stat-value">{{ formatTime(device.firstSeen, true) }}</div>
                                </div>
                                <div class="device-stat">
                                    <div class="device-stat-label">Last Seen</div>
                                    <div class="device-stat-value">{{ formatTime(device.lastSeen, true) }}</div>
                                </div>
                            </div>
                        </div>
                        <div v-if="devicesList.length === 0" class="empty-state">
                            <i class="fas fa-plug"></i>
                            <p>No devices connected yet</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- PGNs Panel -->
            <div class="panel">
                <div class="panel-header">
                    <h3 class="panel-title">
                        <i class="fas fa-stream"></i>
                        {{ panelTitle }}
                    </h3>
                    <span class="stat-number" style="font-size: 1.5rem;">{{ filteredPgns.length }}</span>
                </div>
                <div class="panel-content">
                    <div class="pgns-grid">
                        <div
                                v-for="pgn in filteredPgns"
                                :key="pgn.id"
                                class="pgn-card"
                                :class="{ updated: pgn.isNew }"
                        >
                            <div class="pgn-header">
                                <span class="pgn-id">PGN {{ pgn.pgn }}</span>
                                <span style="color: var(--text-light); font-size: 0.9rem;">
                                        Device {{ pgn.src }}
                                    </span>
                            </div>
                            <div class="pgn-description">{{ pgn.description }}</div>
                            <div class="fields-grid">
                                <div
                                        v-for="(value, field) in pgn.fields"
                                        :key="field"
                                        class="field-row"
                                        :class="{ updated: pgn.updatedFields?.includes(field) }"
                                >
                                    <span class="field-name">{{ field }}</span>
                                    <span class="field-value">{{ formatValue(value) }}</span>
                                </div>
                            </div>
                            <div class="pgn-footer">
                                <span>{{ formatTime(pgn.timestamp) }}</span>
                                <span style="color: var(--text-light);">
                                        {{ pgn.direction || 'Unknown' }}
                                    </span>
                            </div>
                        </div>
                        <div v-if="filteredPgns.length === 0" class="empty-state">
                            <i class="fas fa-search"></i>
                            <p>No PGNs match your filters</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- History Panel -->
            <div class="panel">
                <div class="panel-header">
                    <h3 class="panel-title">
                        <i class="fas fa-history"></i>
                        Recent History
                    </h3>
                    <button class="btn" @click="clearHistory" style="padding: 5px 10px; font-size: 0.9rem;">
                        Clear
                    </button>
                </div>
                <div class="panel-content">
                    <div class="history-list">
                        <div
                                v-for="item in filteredHistory"
                                :key="item.id"
                                class="history-item"
                        >
                            <div class="history-header">
                                <span class="history-pgn">PGN {{ item.pgn }}</span>
                                <span class="history-device">Device {{ item.src }}</span>
                            </div>
                            <div class="history-description">{{ item.description }}</div>
                            <div class="history-time">
                                {{ formatTime(item.timestamp) }}
                            </div>
                        </div>
                        <div v-if="filteredHistory.length === 0" class="empty-state">
                            <i class="fas fa-clock"></i>
                            <p>No history yet</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/js/all.min.js"></script>
<script>
    const {createApp, ref, computed, onMounted, onUnmounted} = Vue;

    createApp({
        setup()
        {
            // WebSocket state
            const ws = ref(null);
            const isConnected = ref(false);
            const autoUpdate = ref(true);

            // Data stores
            const devices = ref(new Map()); // Map<src, deviceData>
            const pgns = ref(new Map()); // Map<src, Map<pgn, pgnData>>
            const history = ref([]); // Array of all received PGNs

            // UI state
            const selectedDevice = ref(null);
            const searchQuery = ref('');
            const deviceFilter = ref('');
            const pgnFilter = ref('');
            const MAX_HISTORY = 5000;

            // Connect to WebSocket
            function connectWebSocket()
            {
                const wsUrl = 'ws://localhost:8080';
                ws.value = new WebSocket(wsUrl);

                ws.value.onopen = () => {
                    console.log('WebSocket connected', ws);
                    isConnected.value = true;
                };

                ws.value.onmessage = (event) => {
                    if (!autoUpdate.value) return;

                    const data = JSON.parse(event.data);
                    console.log(data);
                    if (data.type === 'pgn_update') {
                        processPgnUpdate(data.data);
                    }
                };

                ws.value.onclose = () => {
                    console.log('WebSocket disconnected', ws);
                    isConnected.value = false;
                    setTimeout(connectWebSocket, 3000);
                };

                ws.value.onerror = (error) => {
                    console.error('WebSocket error:', error, ws);
                };
            }

            // Process incoming PGN
            function processPgnUpdate(pgnData)
            {
                const src = pgnData.src;
                const pgnId = pgnData.pgn;

                // 1. Update device
                updateDeviceData(src, pgnData);

                // 2. Update PGN data (without flicker)
                updatePgnData(src, pgnId, pgnData);

                // 3. Add to history
                addToHistory(pgnData);
            }


// Extract device information from PGNs
            function extractDeviceInfo(pgn)
            {
                const deviceInfo = {
                    src:       pgn.src,
                    timestamp: new Date().toISOString(),
                    lastSeen:  Date.now()
                };

                // Extract device information from different PGNs
                switch (pgn.pgn) {
                    case 60928: // ISO Address Claim
                        if (pgn.fields) {
                            deviceInfo.name = pgn.fields.DeviceName || pgn.fields.DeviceFunction || `Device ${pgn.src}`;
                            deviceInfo.manufacturerCode = pgn.fields.ManufacturerCode;
                            deviceInfo.deviceInstance = pgn.fields.DeviceInstance;
                            deviceInfo.deviceFunction = pgn.fields.DeviceFunction;
                            deviceInfo.deviceClass = pgn.fields.DeviceClass;
                            deviceInfo.isoAddress = pgn.fields.ISOAddress;
                        }
                        break;

                    case 126996: // Product Information
                        if (pgn.fields) {
                            deviceInfo.n2kVersion = pgn.fields.N2KVersion;
                            deviceInfo.productCode = pgn.fields.ProductCode;
                            deviceInfo.modelId = pgn.fields.ModelID;
                            deviceInfo.softwareVersion = pgn.fields.SoftwareVersionCode;
                            deviceInfo.modelVersion = pgn.fields.ModelVersion;
                            deviceInfo.modelSerialCode = pgn.fields.ModelSerialCode;
                            deviceInfo.certificationLevel = pgn.fields.CertificationLevel;
                            deviceInfo.loadEquivalency = pgn.fields.LoadEquivalency;
                        }
                        break;

                    case 126998: // Configuration Information
                        if (pgn.fields) {
                            deviceInfo.installationDescription1 = pgn.fields.InstallationDescription1;
                            deviceInfo.installationDescription2 = pgn.fields.InstallationDescription2;
                            deviceInfo.manufacturerInformation = pgn.fields.ManufacturerInformation;
                        }
                        break;

                    case 127237: // Heading/Track Control
                    case 127250: // Vessel Heading
                    case 127251: // Rate of Turn
                    case 127257: // Attitude
                        // These are sensor PGNs, track what the device is measuring
                        if (pgn.fields) {
                            deviceInfo.sensorType = getSensorType(pgn.pgn);
                            deviceInfo.measurements = deviceInfo.measurements || [];
                            const measurement = {
                                pgn:         pgn.pgn,
                                description: pgn.description,
                                timestamp:   new Date().toISOString()
                            };
                            deviceInfo.measurements.push(measurement);
                            // Keep only last 10 measurements
                            if (deviceInfo.measurements.length > 10) {
                                deviceInfo.measurements.shift();
                            }
                        }
                        break;
                }

                return deviceInfo;
            }

            function getSensorType(pgn)
            {
                const sensorMap = {
                    127237: 'Heading/Track Control',
                    127250: 'Vessel Heading',
                    127251: 'Rate of Turn',
                    127257: 'Attitude',
                    127488: 'Engine Parameters Rapid',
                    127489: 'Engine Parameters Dynamic',
                    127493: 'Transmission Parameters',
                    127497: 'Trip Fuel Consumption',
                    127498: 'Engine Parameters Static',
                    127501: 'Binary Status',
                    127505: 'Fluid Level',
                    127506: 'DC Detailed Status',
                    127507: 'Charger Status',
                    127508: 'Battery Status',
                    127509: 'Inverter Status',
                    128275: 'Distance Log',
                    128259: 'Speed',
                    128267: 'Water Depth',
                    129025: 'Position Rapid Update',
                    129026: 'COG & SOG Rapid Update',
                    129027: 'Position Delta High Precision',
                    129028: 'Altitude Delta High Precision',
                    129029: 'GNSS Position Data',
                    129033: 'Time & Date',
                    129038: 'AIS Class A Position Report',
                    129039: 'AIS Class B Position Report',
                    129040: 'AIS Class B Extended Position Report',
                    129041: 'AIS Aids to Navigation (AtoN) Report',
                    129283: 'Cross Track Error',
                    129284: 'Navigation Data'
                };
                return sensorMap[pgn] || 'Unknown Sensor';
            }

            // Update device information
            function updateDeviceData(src, pgnData)
            {
                const now = Date.now();

                if (!devices.value.has(src)) {
                    devices.value.set(src, {
                        src,
                        firstSeen: now,
                        lastSeen:  now,
                        pgnCount:  0,
                        updates:   1,
                        pgns:      new Set()
                    });
                }

                const device = devices.value.get(src);
                device.lastSeen = now;
                device.updates++;


                //we update it!

                //if the pgn has data about device update the device
                // console.log(device, pgnData);
                if (!device.pgns.has(pgnData.pgn)) {
                    device.pgnCount++;
                    device.pgns.add(pgnData.pgn);
                }
            }

            // Update PGN data efficiently
            function updatePgnData(src, pgnId, newData)
            {
                if (!pgns.value.has(src)) {
                    pgns.value.set(src, new Map());
                }

                const devicePgns = pgns.value.get(src);
                const existingPgn = devicePgns.get(pgnId);

                // Find changed fields
                const updatedFields = [];
                if (existingPgn) {
                    Object.keys(newData.fields).forEach(field => {
                        if (JSON.stringify(existingPgn.fields[field]) !==
                            JSON.stringify(newData.fields[field])) {
                            updatedFields.push(field);
                        }
                    });
                }

                // Mark as new for animation
                newData.isNew = true;
                newData.updatedFields = updatedFields;

                // Update the PGN
                devicePgns.set(pgnId, newData);

                // Clear animation after delay
                setTimeout(() => {
                    const currentPgn = pgns.value.get(src)?.get(pgnId);
                    if (currentPgn) {
                        currentPgn.isNew = false;
                        currentPgn.updatedFields = [];
                    }
                }, 1000);
            }

            // Add to history
            function addToHistory(pgnData)
            {
                history.value.unshift({
                    ...pgnData,
                    historyId: `hist_${Date.now()}_${Math.random()}`
                });

                // Limit history size
                if (history.value.length > MAX_HISTORY) {
                    history.value.length = MAX_HISTORY;
                }
            }

            // Computed properties
            const connectionStatus = computed(() =>
                isConnected.value ? 'Connected' : 'Disconnected'
            );

            const devicesList = computed(() => {
                return Array.from(devices.value.values())
                            .sort((a, b) => a.src - b.src)
                            .map(device => ({
                                ...device,
                                firstSeen: new Date(device.firstSeen),
                                lastSeen:  new Date(device.lastSeen)
                            }));
            });

            const allPgns = computed(() => {
                const all = [];
                for (const [src, devicePgnsMap] of pgns.value.entries()) {
                    for (const [pgnId, pgnData] of devicePgnsMap.entries()) {
                        all.push({
                            ...pgnData,
                            deviceSrc: src
                        });
                    }
                }
                return all.sort((a, b) => b.timestamp.localeCompare(a.timestamp));
            });

            const filteredPgns = computed(() => {
                let filtered = allPgns.value;

                // Filter by selected device
                if (selectedDevice.value) {
                    filtered = filtered.filter(pgn => pgn.src === selectedDevice.value);
                }

                // Filter by device filter
                if (deviceFilter.value) {
                    filtered = filtered.filter(pgn =>
                        pgn.src.toString() === deviceFilter.value
                    );
                }

                // Filter by PGN filter
                if (pgnFilter.value) {
                    filtered = filtered.filter(pgn =>
                        pgn.pgn.toString() === pgnFilter.value.toString()
                    );
                }

                // Filter by search query
                if (searchQuery.value) {
                    const query = searchQuery.value.toLowerCase();
                    filtered = filtered.filter(pgn =>
                        pgn.description.toLowerCase().includes(query) ||
                        pgn.pgn.toString().includes(query) ||
                        Object.keys(pgn.fields || {}).some(field =>
                            field.toLowerCase().includes(query)
                        ) ||
                        Object.values(pgn.fields || {}).some(value =>
                            String(value).toLowerCase().includes(query)
                        )
                    );
                }

                //@todo I need to sort the pgn by id
                // Sort PGNs by their numeric PGN id ascending
                filtered.sort((a, b) => (Number(a.src) || 0) - (Number(b.src) || 0));
                filtered.sort((a, b) => (Number(a.pgn) || 0) - (Number(b.pgn) || 0));

                return filtered;
            });

            const filteredHistory = computed(() => {
                let filtered = history.value;

                // Apply same filters as PGNs
                if (deviceFilter.value) {
                    filtered = filtered.filter(item =>
                        item.src.toString() === deviceFilter.value
                    );
                }

                if (pgnFilter.value) {
                    filtered = filtered.filter(item =>
                        item.pgn.toString() === pgnFilter.value
                    );
                }

                if (searchQuery.value) {
                    const query = searchQuery.value.toLowerCase();
                    filtered = filtered.filter(item =>
                        item.description.toLowerCase().includes(query) ||
                        item.pgn.toString().includes(query)
                    );
                }

                return filtered.slice(0, 50); // Show last 50 history items
            });

            const totalDevices = computed(() => devices.value.size);

            const totalPgns = computed(() => allPgns.value.length);

            const totalUpdates = computed(() =>
                Array.from(devices.value.values())
                     .reduce((sum, device) => sum + device.updates, 0)
            );

            const uniquePgns = computed(() => {
                const pgnSet = new Set();
                allPgns.value.forEach(pgn => pgnSet.add(pgn.pgn));
                return Array.from(pgnSet).sort((a, b) => a - b);
            });

            const panelTitle = computed(() => {
                if (selectedDevice.value) {
                    return `Device ${selectedDevice.value} PGNs`;
                }
                if (deviceFilter.value) {
                    return `Device ${deviceFilter.value} PGNs`;
                }
                return 'All PGNs';
            });

            // Methods
            function selectDevice(src)
            {
                selectedDevice.value = selectedDevice.value === src ? null : src;
            }

            function toggleAutoUpdate()
            {
                autoUpdate.value = !autoUpdate.value;
            }

            function clearHistory()
            {
                if (confirm('Clear all history?')) {
                    history.value = [];
                }
            }

            function formatTime(timestamp, short = false)
            {
                if (!timestamp) return 'N/A';

                const date = timestamp instanceof Date ? timestamp : new Date(timestamp);
                const now = new Date();
                const diff = now - date;

                if (short) {
                    const minutes = Math.floor(diff / 60000);
                    if (minutes < 1) return 'Just now';
                    if (minutes < 60) return `${minutes}m ago`;
                    return date.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'});
                }

                return date.toLocaleTimeString([], {
                    hour:                   '2-digit',
                    minute:                 '2-digit',
                    second:                 '2-digit',
                    fractionalSecondDigits: 3
                });
            }

            function formatValue(value)
            {
                if (value === null || value === undefined) return 'null';
                if (typeof value === 'object') return JSON.stringify(value);
                return String(value);
            }

            // Lifecycle
            onMounted(() => {
                connectWebSocket();
            });

            onUnmounted(() => {
                if (ws.value) {
                    ws.value.close();
                }
            });

            return {
                // State
                ws,
                isConnected,
                autoUpdate,
                selectedDevice,
                searchQuery,
                deviceFilter,
                pgnFilter,
                history,

                // Computed
                connectionStatus,
                devicesList,
                filteredPgns,
                filteredHistory,
                totalDevices,
                totalPgns,
                totalUpdates,
                uniquePgns,
                panelTitle,

                // Methods
                selectDevice,
                toggleAutoUpdate,
                clearHistory,
                formatTime,
                formatValue
            };
        }
    }).mount('#app');
</script>
</body>
</html>